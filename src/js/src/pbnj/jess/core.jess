; vim: ft=clojure

(macro fn [args &body]
  (do
    (unless (vector? args) (throw "arguments should be a vector"))
    (list 'paren
      (cons 'function
            (cons args
                (mori/reduce
                  (lambda [l exp]
                          (if (empty? l) (cons (list 'return exp) l) (cons exp l)))
                  (list)
                  (reverse body)))))))

(macro class [nm fields &methods]
  (let [klass (symbol nm)
        assigns (map-indexed
                  (lambda [i f]
                          (list '.-set! 'this (name f) (list '.- 'arguments i))) fields)
        ctr (cons 'function (cons nm (cons (apply vector fields) assigns)))
        meths (mori/map (lambda [meth]
                           (let [n (str (first meth))
                                 args (first (rest meth))
                                 body (rest (rest meth))]
                             (list '.-set! klass (vector "prototype" n) (cons 'fn (cons args body))))) methods)
        proto (cons (list '.-set! klass "prototype" (hash-map)) meths)]
    (into (list) (reverse (concat (list 'do) (list ctr) proto (list klass))))))

(comment
(class Point [x y]
       (toString
         []
         (pbnj.core.str "(" this.x ", " this.y ")"))
       (distance
         [that]
         (Math.sqrt (+ (Math.pow (- that.x this.x) 2) (Math.pow (- that.y this.y) 2)))))

(set! window.point (fn [x y] (new Point x y)))

(var p1 (new Point 3 4))

(console.log (.- p1 x))
(console.log p1.y)
(console.log (instance? p1 Point))
(console.log (type 1))
(console.log (. p1 toString))

(var i 0)
(while (< i 10)
  (console.log i)
  (++ i))
)
