; vim: ft=clojure

(macro class [nm fields &methods]
  (let [klass (symbol nm)
        assigns (map-indexed
                  (lambda [i f]
                          (list '.-set! 'this (name f) (list '.- 'arguments i))) fields)
        ctr (cons 'function (cons nm (cons (apply vector fields) assigns)))
        meths (mori/map (lambda [meth]
                           (let [n (str (first meth))
                                 args (first (rest meth))
                                 body (rest (rest meth))]
                             (list '.-set! klass (vector "prototype" n) (cons 'function (cons args body))))) methods)
        proto (cons (list '.-set! klass "prototype" (hash-map)) meths)]
    (into (list) (reverse (concat (list 'do) (list ctr) proto (list klass))))))

(macro fn [args &body]
  (do
    (unless (vector? args) (throw "arguments should be a vector"))
    (cons 'function (cons args body))))


(class Point [x y]
       (toString [] (return (pbnj.core.str "(" this.x ", " this.y ")")))
       (distance [that] (return (Math.sqrt (+ (Math.pow (- that.x this.x) 2) (Math.pow (- that.y this.y) 2))))))

(set! window.point (function [x y] (return (new Point x y))))

(var p1 (new Point 3 4))

(console.log (.- p1 x))
(console.log p1.y)
(console.log (instance? p1 Point))
(console.log (type 1))
(console.log (. p1 toString))

